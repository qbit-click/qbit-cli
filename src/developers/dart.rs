use std::fs;
use std::path::Path;
use std::process::{Command, Stdio};

use anyhow::{Context, Result, bail};

pub fn init() -> Result<()> {
    let created = create_minimal_project_if_missing()?;
    if created {
        println!("Created minimal Dart console scaffold.");
    } else {
        println!("pubspec.yaml already exists");
    }

    ensure_dart_available()?;
    let command = build_pub_get_command();
    run_dart_command(&command, "dart pub get")?;
    println!("Dart dependencies resolved.");
    Ok(())
}

pub fn add_packages(packages: &[String]) -> Result<()> {
    ensure_dart_available()?;
    ensure_pubspec_exists()?;
    let command = build_dart_pub_command("add", packages)?;
    run_dart_command(&command, "dart pub add")?;
    println!("Added Dart packages: {}", packages.join(", "));
    Ok(())
}

pub fn remove_packages(packages: &[String]) -> Result<()> {
    ensure_dart_available()?;
    ensure_pubspec_exists()?;
    let command = build_dart_pub_command("remove", packages)?;
    run_dart_command(&command, "dart pub remove")?;
    println!("Removed Dart packages: {}", packages.join(", "));
    Ok(())
}

fn create_minimal_project_if_missing() -> Result<bool> {
    let pubspec_path = Path::new("pubspec.yaml");
    if pubspec_path.exists() {
        return Ok(false);
    }

    let package_name = derive_package_name();
    let pubspec = build_pubspec_yaml(&package_name);
    fs::write(pubspec_path, pubspec.as_bytes()).context("writing pubspec.yaml")?;

    fs::create_dir_all("bin").context("creating bin directory")?;
    let main_path = Path::new("bin").join("main.dart");
    if !main_path.exists() {
        fs::write(&main_path, default_main_dart().as_bytes()).context("writing bin/main.dart")?;
    }

    Ok(true)
}

fn derive_package_name() -> String {
    let raw_name = std::env::current_dir()
        .ok()
        .and_then(|path| {
            path.file_name()
                .map(|value| value.to_string_lossy().to_string())
        })
        .unwrap_or_else(|| "qbit_app".to_string());
    sanitize_package_name(&raw_name)
}

fn sanitize_package_name(input: &str) -> String {
    let mut out = String::new();
    let mut prev_underscore = false;

    for ch in input.chars() {
        let c = ch.to_ascii_lowercase();
        if c.is_ascii_alphanumeric() {
            out.push(c);
            prev_underscore = false;
        } else if !prev_underscore {
            out.push('_');
            prev_underscore = true;
        }
    }

    let trimmed = out.trim_matches('_').to_string();
    let mut name = if trimmed.is_empty() {
        "qbit_app".to_string()
    } else {
        trimmed
    };

    if name
        .chars()
        .next()
        .map(|c| c.is_ascii_digit())
        .unwrap_or(false)
    {
        name = format!("app_{name}");
    }

    name
}

fn build_pubspec_yaml(package_name: &str) -> String {
    format!(
        "name: {package_name}\ndescription: A Dart console application generated by qbit.\nversion: 0.1.0\nenvironment:\n  sdk: \">=3.0.0 <4.0.0\"\n"
    )
}

fn default_main_dart() -> &'static str {
    "void main(List<String> args) {\n  print('Hello, Dart from qbit!');\n}\n"
}

fn ensure_pubspec_exists() -> Result<()> {
    if !Path::new("pubspec.yaml").exists() {
        bail!("No pubspec.yaml found in the current directory. Run `qbit dart init` first.");
    }
    Ok(())
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct DartCommandSpec {
    args: Vec<String>,
}

fn build_pub_get_command() -> DartCommandSpec {
    DartCommandSpec {
        args: vec!["pub".to_string(), "get".to_string()],
    }
}

fn build_dart_pub_command(subcommand: &str, packages: &[String]) -> Result<DartCommandSpec> {
    if packages.is_empty() {
        bail!("No Dart packages were provided.");
    }

    let mut args = Vec::with_capacity(packages.len() + 2);
    args.push("pub".to_string());
    args.push(subcommand.to_string());
    for package in packages {
        let trimmed = package.trim();
        if trimmed.is_empty() {
            bail!("Package names must be non-empty.");
        }
        args.push(trimmed.to_string());
    }

    Ok(DartCommandSpec { args })
}

fn ensure_dart_available() -> Result<()> {
    let status = Command::new("dart")
        .arg("--version")
        .stdin(Stdio::null())
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status();

    match status {
        Ok(st) if st.success() => Ok(()),
        _ => bail!(
            "`dart` executable was not found in PATH. Install Dart SDK (https://dart.dev/get-dart) and ensure `dart --version` works."
        ),
    }
}

fn run_dart_command(command: &DartCommandSpec, label: &str) -> Result<()> {
    let status = Command::new("dart")
        .args(&command.args)
        .stdin(Stdio::inherit())
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .status()
        .with_context(|| format!("running {label}"))?;

    if !status.success() {
        bail!(
            "`{label}` failed (exit code {}). Check that `pubspec.yaml` is valid and retry.",
            status.code().unwrap_or(1)
        );
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn sanitize_package_name_normalizes_invalid_chars() {
        assert_eq!(sanitize_package_name("My App-Name"), "my_app_name");
    }

    #[test]
    fn sanitize_package_name_prefixes_numeric_start() {
        assert_eq!(sanitize_package_name("123tool"), "app_123tool");
    }

    #[test]
    fn pubspec_contains_sdk_constraint() {
        let pubspec = build_pubspec_yaml("sample_app");
        assert!(pubspec.contains("name: sample_app"));
        assert!(pubspec.contains("sdk: \">=3.0.0 <4.0.0\""));
    }

    #[test]
    fn builds_dart_pub_add_command_for_multiple_packages() {
        let command = build_dart_pub_command("add", &["dio".to_string(), "riverpod".to_string()])
            .expect("build command");
        assert_eq!(
            command.args,
            vec![
                "pub".to_string(),
                "add".to_string(),
                "dio".to_string(),
                "riverpod".to_string()
            ]
        );
    }

    #[test]
    fn builds_dart_pub_remove_command() {
        let command =
            build_dart_pub_command("remove", &["dio".to_string()]).expect("build command");
        assert_eq!(
            command.args,
            vec!["pub".to_string(), "remove".to_string(), "dio".to_string()]
        );
    }
}
